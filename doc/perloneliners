#Cleanliness
-w      turn warnings on
-Mstrict        turn the strict pragma on

#Data
-0      (that's a zero) specify the input record separator

-a      split data into an array named @F
-F      specify pattern for -a to use when splitting (see perldoc -f split)

-i      edit files in place (see perldoc perlrun for the many details)

-n      run through all the @ARGV arguments as files, one by one, using <>
-p      same as -n, but will also print the contents of $_

#Execution control
-e      specify a string to execute as a script (multiples add up)
-M      import a module
-I      specify directories to search for modules before standard places

# use warnings "all"; use strict;
perl -w -Mstrict -e ''

# replace all aaa with bbb in file 'test'.
perl -pi -e's/aaa/bbb/' test

# insert line numbers in file 'test'.
perl -pi -e'$_ = sprintf "%04d %s", $., $_' test

# Looking through a file backwards for sshd messages
perl -MFile::ReadBackwards -e'foreach my $name (@ARGV)  \
   { $f = File::ReadBackwards->new($name) || next;      \
     while( $_ = $f->readline ) {print $_ if m/sshd/}}' \
  /var/log/messages

# add first and penultimate columns
perl -lane 'print $F[0] + $F[-2]'

#### Printing a range of lines #### -----------------------------
#
# 1. just lines 15 to 17
perl -ne 'print if 15 .. 17'

# 2. just lines NOT between line 10 and 20
perl -ne 'print unless 10 .. 20'

# 3. lines between START and END
perl -ne 'print if /^START$/ .. /^END$/'

###### In Place Editing ########---------------------------------

# 1. in-place edit of *.c files changing all foo to bar
perl -p -i.bak -e 's/\bfoo\b/bar/g' *.c

# 2. delete first 10 lines
perl -i.old -ne 'print unless 1 .. 10' foo.txt

# 3. change all the isolated oldvar occurrences to newvar
perl -i.old -pe 's{\boldvar\b}{newvar}g' *.[chy]

# 4. increment all numbers found in these files
perl -i.tiny -pe 's/(\d+)/ 1 + $1 /ge' file1 file2 ....

# 5. delete all but lines between START and END
perl -i.old -ne 'print unless /^START$/ .. /^END$/' foo.txt

# 6. binary edit (careful!)
perl -i.bak -pe 's/Mozilla/Slopoke/g' /usr/local/bin/netscape

# Why does 1 .. 10 specify line numbers 1 through 10? Read the "perldoc
# perlop" manual page. Basically, the .. operator iterates through a range.
# Thus, the script does not count 10 lines, it counts 10 iterations of the 
# loop generated by the -n switch (see "perldoc perlrun" and Listing 2 for
# an example of that loop).

# The magic of the -i switch is that it replaces each file in @ARGV with the
# version produced by the script's output on that file. Thus, the -i switch
# makes Perl into an editing text filter. Do not forget to use the backup
# option to the -i switch. Following the i with an extension will make a
# backup of the edited file using that extension.

# Note how the -p and -n switch are used. The -n switch is used when you want
# explicitly to print out data. The -p switch implicitly inserts a print $_
# statement in the loop produced by the -n switch. Thus, the -p switch is
# better for full processing of a file, while the -n switch is better for
# selective file processing, where only specific data needs to be printed.

##### Reversal of files' fortunes #### ---------------------------------

# 1. command-line that reverses the whole input by lines
#    (printing each line in reverse order)
perl -e 'print reverse <>' file1 file2 file3 ....

# 2. command-line that shows each line with its characters backwards
perl -nle 'print scalar reverse $_' file1 file2 file3 ....

# 3. find palindromes in the /usr/dict/words dictionary file
perl -lne '$_ = lc $_; print if $_ eq reverse' /usr/dict/words

# 4. command-line that reverses all the bytes in a file
perl -0777e 'print scalar reverse <>' f1 f2 f3 ...

# 5. command-line that reverses each paragraph in the file but prints
#    them in order
perl -00 -e 'print reverse <>' file1 file2 file3 ....

